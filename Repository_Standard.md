# GitHub Repository Standard

## Overview

These recommendations promote the creation of repositories that are understandable and maintainable.
Repositories may be for code or for documentation.
Someone who was not the original author will be able to understand what it is and how to use it, and potentially contribute to it.
For repositories that are updated infrequently, it will also be easier for the original author to get re-oriented.

## Audience

These recommendations must be followed for critical repositories authored by anyone in the Digital Stewardship unit.
All other contributors to the UGA Libraries GitHub account are encouraged to follow these as well.

## Critical Repositories

A critical repository is one that is needed for daily work at the Libraries, so extra care needs to be taken to keep it usable.
A repository could be classified as critical for a number of reasons:  

- It is currently used by multiple UGA employees
- It is central to a major workflow
- Multiple authors contribute to it
- It might be used by people outside of UGA  

When in doubt, follow the recommendations. They are designed to be as easy to implement as possible.
The most common reason to skip these recommendations is for quick, single use scripts that you never intend to work on again.
Even for those, a little time spent documenting could save you problems later if you unexpectedly do need to use it again.  

## Minimum Required Features

- README
- License
- Requirements (code only)
- Testing Method (code only)

### README

All repositories must include a README.md file. 
The README is the first thing displayed when someone opens a repository.
It should orient users to the purpose of the repository and how to use it.
For what to include, see the [template for a code repository](Code_README_Standard.md) or [template for a documentation repository](Documentation_README_Standard.md).

### License

All repositories must include a LICENSE.txt file.
We have approval from UGA Libraries Administration to include the CC-BY-SA-4.0 License on every repository in the UGA Libraries GitHub account.
Having a license is important for transparency, so everyone knows what they can do with it.
Even if you don't think anyone else will every use this repository, it is still best practice to include and takes very little time.
To add a license, copy the LICENSE.txt file from this repository to your repository.

### Requirements

All code repositories must include a requirements.txt file.
Most code is built on libraries, and these need to be kept up to date to avoid security risks.
Having a requirements.txt file in your repository will allow GitHub to automatically alert you when a library needs to be updated. 
This file can be generated by code editors, such as [PyCharm: requirements.txt instructions](https://www.jetbrains.com/help/pycharm/managing-dependencies.html).  

Additionally, include command line utilities and any other outside resources that script depends on in the Dependencies section of the README.

### Testing Method

All code repositories must include some kind of testing method.
One of the most time-consuming aspects of editing code is to determine if the changes introduced any errors.
Tests let us be confident that a change does not break a script, or cause it to produce incorrect output, once it is already being used in production.
Tests can also be beneficial as you develop code for the first time, making it faster to evaluate its effectiveness.  

For code that is workflow-oriented, where discrete steps are performed on some input and produce a predictable output, 
writing provides an automatic way to validate the code is performing as expected.
Resource: [Getting Started With Testing in Python](https://realpython.com/python-testing/)

In other circumstances, it may be more beneficial to write testing procedures that a developer can use. 
Include step-by-step instructions for what features to try, what input to use, and what the expected output or result should be.

## Additional Recommended Features

- Comments and Docstrings (code only)
- Issues
- Releases
- Supporting Documentation

### Comments and Docstrings

Since our code is typically written and edited by people who do not spend a lot of time coding,
it is helpful to provide more comments than usual within the code to explain the purpose of each code block.

If you use functions, make use of docstrings to document that function. 
This should include the purpose, arguments, and what the function returns. 
Resource: [Python Docstring Conventions](https://peps.python.org/pep-0257/)

### Issues

Use GitHub issues to record ideas for changes.
This creates a central location for ideas and problems, and allows others who use the repo to contribute.
While issues are most often used for code, they can be used in documentation repositories to record ideas for changes.  

When making changes, add comments to the relevant issue to summarize decisions made. 
Once the issue is addressed, or you decide not to implement it, close the issue.  

Common information to include in an issue:
- Description of what needs to be done and why
- Location in code or documentation that needs to be change to address the issue, if known
- Impact the change could have on other areas of the code or documentation
- Ideas for solving the issue
- Reason a priority was chosen  

Use labels to organize and prioritize the issues. 
GitHub has default labels based on general code development workflows, but you can edit these and add more. 
Labels can be used to indicate the type of change (e.g., bug, new feature, update policy), the priority level, 
the document within the repository to edit, or any other classification that would group related ideas together.  

### Releases

Make a new release in GitHub as a way to signal a new version of the repository is ready. 
For code, this could be after implementing a batch of related improvements or reaching some milestone. 
For documentation, this could be after completing a revision cycle.  

Releases can include extra files, like an executable for local set up of the code in a repository, but that is not required. 
At its simplest, it is a way to name the current state of the repository and document the primary changes from the previous version, 
which could help users of the repository stay up to date without needing to read through the change history of the repository.

### Supporting Documentation

Include all supporting documentation needed to provide context for how to use the repository. 
For code, this could include sample input, sample output, and/or documentation for the workflow that the code is part of.  

*Any ideas on what this might look for with documentation? Or is it only for code?*
